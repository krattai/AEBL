// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/DIR.proto

#ifndef PROTOBUF_xtreemfs_2fDIR_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fDIR_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
#include "xtreemfs/GlobalTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

class AddressMapping;
class AddressMappingSet;
class DirService;
class ServiceDataMap;
class Service;
class ServiceSet;
class Configuration;
class addressMappingGetRequest;
class addressMappingGetResponse;
class addressMappingSetResponse;
class globalTimeSGetResponse;
class serviceDeregisterRequest;
class serviceGetByNameRequest;
class serviceGetByUUIDRequest;
class serviceGetByTypeRequest;
class serviceRegisterRequest;
class serviceRegisterResponse;
class configurationGetRequest;
class configurationSetResponse;

enum ServiceType {
  SERVICE_TYPE_MIXED = 0,
  SERVICE_TYPE_MRC = 1,
  SERVICE_TYPE_OSD = 2,
  SERVICE_TYPE_VOLUME = 3,
  SERVICE_TYPE_DIR = 4
};
bool ServiceType_IsValid(int value);
const ServiceType ServiceType_MIN = SERVICE_TYPE_MIXED;
const ServiceType ServiceType_MAX = SERVICE_TYPE_DIR;
const int ServiceType_ARRAYSIZE = ServiceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceType_descriptor();
inline const ::std::string& ServiceType_Name(ServiceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceType_descriptor(), value);
}
inline bool ServiceType_Parse(
    const ::std::string& name, ServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceType>(
    ServiceType_descriptor(), name, value);
}
enum ServiceStatus {
  SERVICE_STATUS_AVAIL = 0,
  SERVICE_STATUS_TO_BE_REMOVED = 1,
  SERVICE_STATUS_REMOVED = 2
};
bool ServiceStatus_IsValid(int value);
const ServiceStatus ServiceStatus_MIN = SERVICE_STATUS_AVAIL;
const ServiceStatus ServiceStatus_MAX = SERVICE_STATUS_REMOVED;
const int ServiceStatus_ARRAYSIZE = ServiceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceStatus_descriptor();
inline const ::std::string& ServiceStatus_Name(ServiceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceStatus_descriptor(), value);
}
inline bool ServiceStatus_Parse(
    const ::std::string& name, ServiceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceStatus>(
    ServiceStatus_descriptor(), name, value);
}
// ===================================================================

class AddressMapping : public ::google::protobuf::Message {
 public:
  AddressMapping();
  virtual ~AddressMapping();

  AddressMapping(const AddressMapping& from);

  inline AddressMapping& operator=(const AddressMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressMapping& default_instance();

  void Swap(AddressMapping* other);

  // implements Message ----------------------------------------------

  AddressMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressMapping& from);
  void MergeFrom(const AddressMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // required fixed64 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // required string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // required string address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // required fixed32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string match_network = 6;
  inline bool has_match_network() const;
  inline void clear_match_network();
  static const int kMatchNetworkFieldNumber = 6;
  inline const ::std::string& match_network() const;
  inline void set_match_network(const ::std::string& value);
  inline void set_match_network(const char* value);
  inline void set_match_network(const char* value, size_t size);
  inline ::std::string* mutable_match_network();
  inline ::std::string* release_match_network();
  inline void set_allocated_match_network(::std::string* match_network);

  // required fixed32 ttl_s = 7;
  inline bool has_ttl_s() const;
  inline void clear_ttl_s();
  static const int kTtlSFieldNumber = 7;
  inline ::google::protobuf::uint32 ttl_s() const;
  inline void set_ttl_s(::google::protobuf::uint32 value);

  // required string uri = 8;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 8;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  inline void set_allocated_uri(::std::string* uri);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.AddressMapping)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_match_network();
  inline void clear_has_match_network();
  inline void set_has_ttl_s();
  inline void clear_has_ttl_s();
  inline void set_has_uri();
  inline void clear_has_uri();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::google::protobuf::uint64 version_;
  ::std::string* protocol_;
  ::std::string* address_;
  ::std::string* match_network_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 ttl_s_;
  ::std::string* uri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static AddressMapping* default_instance_;
};
// -------------------------------------------------------------------

class AddressMappingSet : public ::google::protobuf::Message {
 public:
  AddressMappingSet();
  virtual ~AddressMappingSet();

  AddressMappingSet(const AddressMappingSet& from);

  inline AddressMappingSet& operator=(const AddressMappingSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressMappingSet& default_instance();

  void Swap(AddressMappingSet* other);

  // implements Message ----------------------------------------------

  AddressMappingSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressMappingSet& from);
  void MergeFrom(const AddressMappingSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.AddressMapping mappings = 1;
  inline int mappings_size() const;
  inline void clear_mappings();
  static const int kMappingsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::AddressMapping& mappings(int index) const;
  inline ::xtreemfs::pbrpc::AddressMapping* mutable_mappings(int index);
  inline ::xtreemfs::pbrpc::AddressMapping* add_mappings();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::AddressMapping >&
      mappings() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::AddressMapping >*
      mutable_mappings();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.AddressMappingSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::AddressMapping > mappings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static AddressMappingSet* default_instance_;
};
// -------------------------------------------------------------------

class DirService : public ::google::protobuf::Message {
 public:
  DirService();
  virtual ~DirService();

  DirService(const DirService& from);

  inline DirService& operator=(const DirService& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirService& default_instance();

  void Swap(DirService* other);

  // implements Message ----------------------------------------------

  DirService* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirService& from);
  void MergeFrom(const DirService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // required fixed32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string protocol = 3;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 3;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const char* value, size_t size);
  inline ::std::string* mutable_protocol();
  inline ::std::string* release_protocol();
  inline void set_allocated_protocol(::std::string* protocol);

  // required fixed32 interface_version = 4;
  inline bool has_interface_version() const;
  inline void clear_interface_version();
  static const int kInterfaceVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 interface_version() const;
  inline void set_interface_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.DirService)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_interface_version();
  inline void clear_has_interface_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;
  ::std::string* protocol_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 interface_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static DirService* default_instance_;
};
// -------------------------------------------------------------------

class ServiceDataMap : public ::google::protobuf::Message {
 public:
  ServiceDataMap();
  virtual ~ServiceDataMap();

  ServiceDataMap(const ServiceDataMap& from);

  inline ServiceDataMap& operator=(const ServiceDataMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceDataMap& default_instance();

  void Swap(ServiceDataMap* other);

  // implements Message ----------------------------------------------

  ServiceDataMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceDataMap& from);
  void MergeFrom(const ServiceDataMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.KeyValuePair data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::KeyValuePair& data(int index) const;
  inline ::xtreemfs::pbrpc::KeyValuePair* mutable_data(int index);
  inline ::xtreemfs::pbrpc::KeyValuePair* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ServiceDataMap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static ServiceDataMap* default_instance_;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  void Swap(Service* other);

  // implements Message ----------------------------------------------

  Service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.ServiceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::xtreemfs::pbrpc::ServiceType type() const;
  inline void set_type(::xtreemfs::pbrpc::ServiceType value);

  // required string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // required fixed64 version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required fixed64 last_updated_s = 5;
  inline bool has_last_updated_s() const;
  inline void clear_last_updated_s();
  static const int kLastUpdatedSFieldNumber = 5;
  inline ::google::protobuf::uint64 last_updated_s() const;
  inline void set_last_updated_s(::google::protobuf::uint64 value);

  // required .xtreemfs.pbrpc.ServiceDataMap data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::xtreemfs::pbrpc::ServiceDataMap& data() const;
  inline ::xtreemfs::pbrpc::ServiceDataMap* mutable_data();
  inline ::xtreemfs::pbrpc::ServiceDataMap* release_data();
  inline void set_allocated_data(::xtreemfs::pbrpc::ServiceDataMap* data);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Service)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_last_updated_s();
  inline void clear_has_last_updated_s();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::google::protobuf::uint64 version_;
  ::std::string* name_;
  ::google::protobuf::uint64 last_updated_s_;
  ::xtreemfs::pbrpc::ServiceDataMap* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// -------------------------------------------------------------------

class ServiceSet : public ::google::protobuf::Message {
 public:
  ServiceSet();
  virtual ~ServiceSet();

  ServiceSet(const ServiceSet& from);

  inline ServiceSet& operator=(const ServiceSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceSet& default_instance();

  void Swap(ServiceSet* other);

  // implements Message ----------------------------------------------

  ServiceSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceSet& from);
  void MergeFrom(const ServiceSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.Service services = 1;
  inline int services_size() const;
  inline void clear_services();
  static const int kServicesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Service& services(int index) const;
  inline ::xtreemfs::pbrpc::Service* mutable_services(int index);
  inline ::xtreemfs::pbrpc::Service* add_services();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Service >&
      services() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Service >*
      mutable_services();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ServiceSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Service > services_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static ServiceSet* default_instance_;
};
// -------------------------------------------------------------------

class Configuration : public ::google::protobuf::Message {
 public:
  Configuration();
  virtual ~Configuration();

  Configuration(const Configuration& from);

  inline Configuration& operator=(const Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configuration& default_instance();

  void Swap(Configuration* other);

  // implements Message ----------------------------------------------

  Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Configuration& from);
  void MergeFrom(const Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // repeated .xtreemfs.pbrpc.KeyValuePair parameter = 2;
  inline int parameter_size() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::KeyValuePair& parameter(int index) const;
  inline ::xtreemfs::pbrpc::KeyValuePair* mutable_parameter(int index);
  inline ::xtreemfs::pbrpc::KeyValuePair* add_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
      parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
      mutable_parameter();

  // required fixed64 version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Configuration)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair > parameter_;
  ::google::protobuf::uint64 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static Configuration* default_instance_;
};
// -------------------------------------------------------------------

class addressMappingGetRequest : public ::google::protobuf::Message {
 public:
  addressMappingGetRequest();
  virtual ~addressMappingGetRequest();

  addressMappingGetRequest(const addressMappingGetRequest& from);

  inline addressMappingGetRequest& operator=(const addressMappingGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const addressMappingGetRequest& default_instance();

  void Swap(addressMappingGetRequest* other);

  // implements Message ----------------------------------------------

  addressMappingGetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const addressMappingGetRequest& from);
  void MergeFrom(const addressMappingGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.addressMappingGetRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static addressMappingGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class addressMappingGetResponse : public ::google::protobuf::Message {
 public:
  addressMappingGetResponse();
  virtual ~addressMappingGetResponse();

  addressMappingGetResponse(const addressMappingGetResponse& from);

  inline addressMappingGetResponse& operator=(const addressMappingGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const addressMappingGetResponse& default_instance();

  void Swap(addressMappingGetResponse* other);

  // implements Message ----------------------------------------------

  addressMappingGetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const addressMappingGetResponse& from);
  void MergeFrom(const addressMappingGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .xtreemfs.pbrpc.AddressMappingSet result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::AddressMappingSet& result() const;
  inline ::xtreemfs::pbrpc::AddressMappingSet* mutable_result();
  inline ::xtreemfs::pbrpc::AddressMappingSet* release_result();
  inline void set_allocated_result(::xtreemfs::pbrpc::AddressMappingSet* result);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.addressMappingGetResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::AddressMappingSet* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static addressMappingGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class addressMappingSetResponse : public ::google::protobuf::Message {
 public:
  addressMappingSetResponse();
  virtual ~addressMappingSetResponse();

  addressMappingSetResponse(const addressMappingSetResponse& from);

  inline addressMappingSetResponse& operator=(const addressMappingSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const addressMappingSetResponse& default_instance();

  void Swap(addressMappingSetResponse* other);

  // implements Message ----------------------------------------------

  addressMappingSetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const addressMappingSetResponse& from);
  void MergeFrom(const addressMappingSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 new_version = 1;
  inline bool has_new_version() const;
  inline void clear_new_version();
  static const int kNewVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 new_version() const;
  inline void set_new_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.addressMappingSetResponse)
 private:
  inline void set_has_new_version();
  inline void clear_has_new_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 new_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static addressMappingSetResponse* default_instance_;
};
// -------------------------------------------------------------------

class globalTimeSGetResponse : public ::google::protobuf::Message {
 public:
  globalTimeSGetResponse();
  virtual ~globalTimeSGetResponse();

  globalTimeSGetResponse(const globalTimeSGetResponse& from);

  inline globalTimeSGetResponse& operator=(const globalTimeSGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const globalTimeSGetResponse& default_instance();

  void Swap(globalTimeSGetResponse* other);

  // implements Message ----------------------------------------------

  globalTimeSGetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const globalTimeSGetResponse& from);
  void MergeFrom(const globalTimeSGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 time_in_seconds = 1;
  inline bool has_time_in_seconds() const;
  inline void clear_time_in_seconds();
  static const int kTimeInSecondsFieldNumber = 1;
  inline ::google::protobuf::uint64 time_in_seconds() const;
  inline void set_time_in_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.globalTimeSGetResponse)
 private:
  inline void set_has_time_in_seconds();
  inline void clear_has_time_in_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 time_in_seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static globalTimeSGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class serviceDeregisterRequest : public ::google::protobuf::Message {
 public:
  serviceDeregisterRequest();
  virtual ~serviceDeregisterRequest();

  serviceDeregisterRequest(const serviceDeregisterRequest& from);

  inline serviceDeregisterRequest& operator=(const serviceDeregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceDeregisterRequest& default_instance();

  void Swap(serviceDeregisterRequest* other);

  // implements Message ----------------------------------------------

  serviceDeregisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serviceDeregisterRequest& from);
  void MergeFrom(const serviceDeregisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.serviceDeregisterRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static serviceDeregisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class serviceGetByNameRequest : public ::google::protobuf::Message {
 public:
  serviceGetByNameRequest();
  virtual ~serviceGetByNameRequest();

  serviceGetByNameRequest(const serviceGetByNameRequest& from);

  inline serviceGetByNameRequest& operator=(const serviceGetByNameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceGetByNameRequest& default_instance();

  void Swap(serviceGetByNameRequest* other);

  // implements Message ----------------------------------------------

  serviceGetByNameRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serviceGetByNameRequest& from);
  void MergeFrom(const serviceGetByNameRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.serviceGetByNameRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static serviceGetByNameRequest* default_instance_;
};
// -------------------------------------------------------------------

class serviceGetByUUIDRequest : public ::google::protobuf::Message {
 public:
  serviceGetByUUIDRequest();
  virtual ~serviceGetByUUIDRequest();

  serviceGetByUUIDRequest(const serviceGetByUUIDRequest& from);

  inline serviceGetByUUIDRequest& operator=(const serviceGetByUUIDRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceGetByUUIDRequest& default_instance();

  void Swap(serviceGetByUUIDRequest* other);

  // implements Message ----------------------------------------------

  serviceGetByUUIDRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serviceGetByUUIDRequest& from);
  void MergeFrom(const serviceGetByUUIDRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.serviceGetByUUIDRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static serviceGetByUUIDRequest* default_instance_;
};
// -------------------------------------------------------------------

class serviceGetByTypeRequest : public ::google::protobuf::Message {
 public:
  serviceGetByTypeRequest();
  virtual ~serviceGetByTypeRequest();

  serviceGetByTypeRequest(const serviceGetByTypeRequest& from);

  inline serviceGetByTypeRequest& operator=(const serviceGetByTypeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceGetByTypeRequest& default_instance();

  void Swap(serviceGetByTypeRequest* other);

  // implements Message ----------------------------------------------

  serviceGetByTypeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serviceGetByTypeRequest& from);
  void MergeFrom(const serviceGetByTypeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.ServiceType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::xtreemfs::pbrpc::ServiceType type() const;
  inline void set_type(::xtreemfs::pbrpc::ServiceType value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.serviceGetByTypeRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static serviceGetByTypeRequest* default_instance_;
};
// -------------------------------------------------------------------

class serviceRegisterRequest : public ::google::protobuf::Message {
 public:
  serviceRegisterRequest();
  virtual ~serviceRegisterRequest();

  serviceRegisterRequest(const serviceRegisterRequest& from);

  inline serviceRegisterRequest& operator=(const serviceRegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceRegisterRequest& default_instance();

  void Swap(serviceRegisterRequest* other);

  // implements Message ----------------------------------------------

  serviceRegisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serviceRegisterRequest& from);
  void MergeFrom(const serviceRegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.Service service = 1;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Service& service() const;
  inline ::xtreemfs::pbrpc::Service* mutable_service();
  inline ::xtreemfs::pbrpc::Service* release_service();
  inline void set_allocated_service(::xtreemfs::pbrpc::Service* service);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.serviceRegisterRequest)
 private:
  inline void set_has_service();
  inline void clear_has_service();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::Service* service_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static serviceRegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class serviceRegisterResponse : public ::google::protobuf::Message {
 public:
  serviceRegisterResponse();
  virtual ~serviceRegisterResponse();

  serviceRegisterResponse(const serviceRegisterResponse& from);

  inline serviceRegisterResponse& operator=(const serviceRegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const serviceRegisterResponse& default_instance();

  void Swap(serviceRegisterResponse* other);

  // implements Message ----------------------------------------------

  serviceRegisterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const serviceRegisterResponse& from);
  void MergeFrom(const serviceRegisterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 new_version = 1;
  inline bool has_new_version() const;
  inline void clear_new_version();
  static const int kNewVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 new_version() const;
  inline void set_new_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.serviceRegisterResponse)
 private:
  inline void set_has_new_version();
  inline void clear_has_new_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 new_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static serviceRegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class configurationGetRequest : public ::google::protobuf::Message {
 public:
  configurationGetRequest();
  virtual ~configurationGetRequest();

  configurationGetRequest(const configurationGetRequest& from);

  inline configurationGetRequest& operator=(const configurationGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const configurationGetRequest& default_instance();

  void Swap(configurationGetRequest* other);

  // implements Message ----------------------------------------------

  configurationGetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const configurationGetRequest& from);
  void MergeFrom(const configurationGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.configurationGetRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static configurationGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class configurationSetResponse : public ::google::protobuf::Message {
 public:
  configurationSetResponse();
  virtual ~configurationSetResponse();

  configurationSetResponse(const configurationSetResponse& from);

  inline configurationSetResponse& operator=(const configurationSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const configurationSetResponse& default_instance();

  void Swap(configurationSetResponse* other);

  // implements Message ----------------------------------------------

  configurationSetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const configurationSetResponse& from);
  void MergeFrom(const configurationSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 new_version = 1;
  inline bool has_new_version() const;
  inline void clear_new_version();
  static const int kNewVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 new_version() const;
  inline void set_new_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.configurationSetResponse)
 private:
  inline void set_has_new_version();
  inline void clear_has_new_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 new_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fDIR_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fDIR_2eproto();

  void InitAsDefaultInstance();
  static configurationSetResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// AddressMapping

// required string uuid = 1;
inline bool AddressMapping::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddressMapping::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddressMapping::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddressMapping::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& AddressMapping::uuid() const {
  return *uuid_;
}
inline void AddressMapping::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void AddressMapping::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void AddressMapping::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressMapping::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* AddressMapping::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressMapping::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 version = 2;
inline bool AddressMapping::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddressMapping::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddressMapping::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddressMapping::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 AddressMapping::version() const {
  return version_;
}
inline void AddressMapping::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// required string protocol = 3;
inline bool AddressMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddressMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddressMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddressMapping::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& AddressMapping::protocol() const {
  return *protocol_;
}
inline void AddressMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void AddressMapping::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void AddressMapping::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressMapping::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* AddressMapping::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string address = 4;
inline bool AddressMapping::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddressMapping::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddressMapping::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddressMapping::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& AddressMapping::address() const {
  return *address_;
}
inline void AddressMapping::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AddressMapping::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AddressMapping::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressMapping::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* AddressMapping::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressMapping::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 port = 5;
inline bool AddressMapping::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddressMapping::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddressMapping::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddressMapping::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 AddressMapping::port() const {
  return port_;
}
inline void AddressMapping::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required string match_network = 6;
inline bool AddressMapping::has_match_network() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddressMapping::set_has_match_network() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddressMapping::clear_has_match_network() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddressMapping::clear_match_network() {
  if (match_network_ != &::google::protobuf::internal::kEmptyString) {
    match_network_->clear();
  }
  clear_has_match_network();
}
inline const ::std::string& AddressMapping::match_network() const {
  return *match_network_;
}
inline void AddressMapping::set_match_network(const ::std::string& value) {
  set_has_match_network();
  if (match_network_ == &::google::protobuf::internal::kEmptyString) {
    match_network_ = new ::std::string;
  }
  match_network_->assign(value);
}
inline void AddressMapping::set_match_network(const char* value) {
  set_has_match_network();
  if (match_network_ == &::google::protobuf::internal::kEmptyString) {
    match_network_ = new ::std::string;
  }
  match_network_->assign(value);
}
inline void AddressMapping::set_match_network(const char* value, size_t size) {
  set_has_match_network();
  if (match_network_ == &::google::protobuf::internal::kEmptyString) {
    match_network_ = new ::std::string;
  }
  match_network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressMapping::mutable_match_network() {
  set_has_match_network();
  if (match_network_ == &::google::protobuf::internal::kEmptyString) {
    match_network_ = new ::std::string;
  }
  return match_network_;
}
inline ::std::string* AddressMapping::release_match_network() {
  clear_has_match_network();
  if (match_network_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = match_network_;
    match_network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressMapping::set_allocated_match_network(::std::string* match_network) {
  if (match_network_ != &::google::protobuf::internal::kEmptyString) {
    delete match_network_;
  }
  if (match_network) {
    set_has_match_network();
    match_network_ = match_network;
  } else {
    clear_has_match_network();
    match_network_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 ttl_s = 7;
inline bool AddressMapping::has_ttl_s() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddressMapping::set_has_ttl_s() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddressMapping::clear_has_ttl_s() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddressMapping::clear_ttl_s() {
  ttl_s_ = 0u;
  clear_has_ttl_s();
}
inline ::google::protobuf::uint32 AddressMapping::ttl_s() const {
  return ttl_s_;
}
inline void AddressMapping::set_ttl_s(::google::protobuf::uint32 value) {
  set_has_ttl_s();
  ttl_s_ = value;
}

// required string uri = 8;
inline bool AddressMapping::has_uri() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AddressMapping::set_has_uri() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AddressMapping::clear_has_uri() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AddressMapping::clear_uri() {
  if (uri_ != &::google::protobuf::internal::kEmptyString) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& AddressMapping::uri() const {
  return *uri_;
}
inline void AddressMapping::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void AddressMapping::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void AddressMapping::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressMapping::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    uri_ = new ::std::string;
  }
  return uri_;
}
inline ::std::string* AddressMapping::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressMapping::set_allocated_uri(::std::string* uri) {
  if (uri_ != &::google::protobuf::internal::kEmptyString) {
    delete uri_;
  }
  if (uri) {
    set_has_uri();
    uri_ = uri;
  } else {
    clear_has_uri();
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AddressMappingSet

// repeated .xtreemfs.pbrpc.AddressMapping mappings = 1;
inline int AddressMappingSet::mappings_size() const {
  return mappings_.size();
}
inline void AddressMappingSet::clear_mappings() {
  mappings_.Clear();
}
inline const ::xtreemfs::pbrpc::AddressMapping& AddressMappingSet::mappings(int index) const {
  return mappings_.Get(index);
}
inline ::xtreemfs::pbrpc::AddressMapping* AddressMappingSet::mutable_mappings(int index) {
  return mappings_.Mutable(index);
}
inline ::xtreemfs::pbrpc::AddressMapping* AddressMappingSet::add_mappings() {
  return mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::AddressMapping >&
AddressMappingSet::mappings() const {
  return mappings_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::AddressMapping >*
AddressMappingSet::mutable_mappings() {
  return &mappings_;
}

// -------------------------------------------------------------------

// DirService

// required string address = 1;
inline bool DirService::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirService::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirService::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirService::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& DirService::address() const {
  return *address_;
}
inline void DirService::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void DirService::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void DirService::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirService::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* DirService::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirService::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 port = 2;
inline bool DirService::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirService::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirService::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirService::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DirService::port() const {
  return port_;
}
inline void DirService::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required string protocol = 3;
inline bool DirService::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirService::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirService::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirService::clear_protocol() {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    protocol_->clear();
  }
  clear_has_protocol();
}
inline const ::std::string& DirService::protocol() const {
  return *protocol_;
}
inline void DirService::set_protocol(const ::std::string& value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void DirService::set_protocol(const char* value) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void DirService::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirService::mutable_protocol() {
  set_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}
inline ::std::string* DirService::release_protocol() {
  clear_has_protocol();
  if (protocol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocol_;
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirService::set_allocated_protocol(::std::string* protocol) {
  if (protocol_ != &::google::protobuf::internal::kEmptyString) {
    delete protocol_;
  }
  if (protocol) {
    set_has_protocol();
    protocol_ = protocol;
  } else {
    clear_has_protocol();
    protocol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 interface_version = 4;
inline bool DirService::has_interface_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirService::set_has_interface_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirService::clear_has_interface_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirService::clear_interface_version() {
  interface_version_ = 0u;
  clear_has_interface_version();
}
inline ::google::protobuf::uint32 DirService::interface_version() const {
  return interface_version_;
}
inline void DirService::set_interface_version(::google::protobuf::uint32 value) {
  set_has_interface_version();
  interface_version_ = value;
}

// -------------------------------------------------------------------

// ServiceDataMap

// repeated .xtreemfs.pbrpc.KeyValuePair data = 1;
inline int ServiceDataMap::data_size() const {
  return data_.size();
}
inline void ServiceDataMap::clear_data() {
  data_.Clear();
}
inline const ::xtreemfs::pbrpc::KeyValuePair& ServiceDataMap::data(int index) const {
  return data_.Get(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* ServiceDataMap::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* ServiceDataMap::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
ServiceDataMap::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
ServiceDataMap::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Service

// required .xtreemfs.pbrpc.ServiceType type = 1;
inline bool Service::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::xtreemfs::pbrpc::ServiceType Service::type() const {
  return static_cast< ::xtreemfs::pbrpc::ServiceType >(type_);
}
inline void Service::set_type(::xtreemfs::pbrpc::ServiceType value) {
  assert(::xtreemfs::pbrpc::ServiceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string uuid = 2;
inline bool Service::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Service::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Service::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Service::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Service::uuid() const {
  return *uuid_;
}
inline void Service::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Service::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Service::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Service::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Service::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Service::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 version = 3;
inline bool Service::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Service::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Service::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Service::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 Service::version() const {
  return version_;
}
inline void Service::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// required string name = 4;
inline bool Service::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Service::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Service::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Service::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Service::name() const {
  return *name_;
}
inline void Service::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Service::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Service::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Service::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Service::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Service::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 last_updated_s = 5;
inline bool Service::has_last_updated_s() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Service::set_has_last_updated_s() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Service::clear_has_last_updated_s() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Service::clear_last_updated_s() {
  last_updated_s_ = GOOGLE_ULONGLONG(0);
  clear_has_last_updated_s();
}
inline ::google::protobuf::uint64 Service::last_updated_s() const {
  return last_updated_s_;
}
inline void Service::set_last_updated_s(::google::protobuf::uint64 value) {
  set_has_last_updated_s();
  last_updated_s_ = value;
}

// required .xtreemfs.pbrpc.ServiceDataMap data = 6;
inline bool Service::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Service::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Service::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Service::clear_data() {
  if (data_ != NULL) data_->::xtreemfs::pbrpc::ServiceDataMap::Clear();
  clear_has_data();
}
inline const ::xtreemfs::pbrpc::ServiceDataMap& Service::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::xtreemfs::pbrpc::ServiceDataMap* Service::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::xtreemfs::pbrpc::ServiceDataMap;
  return data_;
}
inline ::xtreemfs::pbrpc::ServiceDataMap* Service::release_data() {
  clear_has_data();
  ::xtreemfs::pbrpc::ServiceDataMap* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Service::set_allocated_data(::xtreemfs::pbrpc::ServiceDataMap* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// ServiceSet

// repeated .xtreemfs.pbrpc.Service services = 1;
inline int ServiceSet::services_size() const {
  return services_.size();
}
inline void ServiceSet::clear_services() {
  services_.Clear();
}
inline const ::xtreemfs::pbrpc::Service& ServiceSet::services(int index) const {
  return services_.Get(index);
}
inline ::xtreemfs::pbrpc::Service* ServiceSet::mutable_services(int index) {
  return services_.Mutable(index);
}
inline ::xtreemfs::pbrpc::Service* ServiceSet::add_services() {
  return services_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Service >&
ServiceSet::services() const {
  return services_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Service >*
ServiceSet::mutable_services() {
  return &services_;
}

// -------------------------------------------------------------------

// Configuration

// required string uuid = 1;
inline bool Configuration::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configuration::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configuration::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configuration::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Configuration::uuid() const {
  return *uuid_;
}
inline void Configuration::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Configuration::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Configuration::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Configuration::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Configuration::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Configuration::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .xtreemfs.pbrpc.KeyValuePair parameter = 2;
inline int Configuration::parameter_size() const {
  return parameter_.size();
}
inline void Configuration::clear_parameter() {
  parameter_.Clear();
}
inline const ::xtreemfs::pbrpc::KeyValuePair& Configuration::parameter(int index) const {
  return parameter_.Get(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* Configuration::mutable_parameter(int index) {
  return parameter_.Mutable(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* Configuration::add_parameter() {
  return parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
Configuration::parameter() const {
  return parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
Configuration::mutable_parameter() {
  return &parameter_;
}

// required fixed64 version = 3;
inline bool Configuration::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configuration::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configuration::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configuration::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 Configuration::version() const {
  return version_;
}
inline void Configuration::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// addressMappingGetRequest

// required string uuid = 1;
inline bool addressMappingGetRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void addressMappingGetRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void addressMappingGetRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void addressMappingGetRequest::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& addressMappingGetRequest::uuid() const {
  return *uuid_;
}
inline void addressMappingGetRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void addressMappingGetRequest::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void addressMappingGetRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* addressMappingGetRequest::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* addressMappingGetRequest::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void addressMappingGetRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// addressMappingGetResponse

// optional .xtreemfs.pbrpc.AddressMappingSet result = 1;
inline bool addressMappingGetResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void addressMappingGetResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void addressMappingGetResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void addressMappingGetResponse::clear_result() {
  if (result_ != NULL) result_->::xtreemfs::pbrpc::AddressMappingSet::Clear();
  clear_has_result();
}
inline const ::xtreemfs::pbrpc::AddressMappingSet& addressMappingGetResponse::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::xtreemfs::pbrpc::AddressMappingSet* addressMappingGetResponse::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::xtreemfs::pbrpc::AddressMappingSet;
  return result_;
}
inline ::xtreemfs::pbrpc::AddressMappingSet* addressMappingGetResponse::release_result() {
  clear_has_result();
  ::xtreemfs::pbrpc::AddressMappingSet* temp = result_;
  result_ = NULL;
  return temp;
}
inline void addressMappingGetResponse::set_allocated_result(::xtreemfs::pbrpc::AddressMappingSet* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// addressMappingSetResponse

// optional fixed64 new_version = 1;
inline bool addressMappingSetResponse::has_new_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void addressMappingSetResponse::set_has_new_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void addressMappingSetResponse::clear_has_new_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void addressMappingSetResponse::clear_new_version() {
  new_version_ = GOOGLE_ULONGLONG(0);
  clear_has_new_version();
}
inline ::google::protobuf::uint64 addressMappingSetResponse::new_version() const {
  return new_version_;
}
inline void addressMappingSetResponse::set_new_version(::google::protobuf::uint64 value) {
  set_has_new_version();
  new_version_ = value;
}

// -------------------------------------------------------------------

// globalTimeSGetResponse

// required fixed64 time_in_seconds = 1;
inline bool globalTimeSGetResponse::has_time_in_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void globalTimeSGetResponse::set_has_time_in_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void globalTimeSGetResponse::clear_has_time_in_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void globalTimeSGetResponse::clear_time_in_seconds() {
  time_in_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_time_in_seconds();
}
inline ::google::protobuf::uint64 globalTimeSGetResponse::time_in_seconds() const {
  return time_in_seconds_;
}
inline void globalTimeSGetResponse::set_time_in_seconds(::google::protobuf::uint64 value) {
  set_has_time_in_seconds();
  time_in_seconds_ = value;
}

// -------------------------------------------------------------------

// serviceDeregisterRequest

// required string uuid = 1;
inline bool serviceDeregisterRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serviceDeregisterRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serviceDeregisterRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serviceDeregisterRequest::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& serviceDeregisterRequest::uuid() const {
  return *uuid_;
}
inline void serviceDeregisterRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void serviceDeregisterRequest::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void serviceDeregisterRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* serviceDeregisterRequest::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* serviceDeregisterRequest::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void serviceDeregisterRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// serviceGetByNameRequest

// required string name = 1;
inline bool serviceGetByNameRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serviceGetByNameRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serviceGetByNameRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serviceGetByNameRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& serviceGetByNameRequest::name() const {
  return *name_;
}
inline void serviceGetByNameRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void serviceGetByNameRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void serviceGetByNameRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* serviceGetByNameRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* serviceGetByNameRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void serviceGetByNameRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// serviceGetByUUIDRequest

// required string name = 1;
inline bool serviceGetByUUIDRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serviceGetByUUIDRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serviceGetByUUIDRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serviceGetByUUIDRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& serviceGetByUUIDRequest::name() const {
  return *name_;
}
inline void serviceGetByUUIDRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void serviceGetByUUIDRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void serviceGetByUUIDRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* serviceGetByUUIDRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* serviceGetByUUIDRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void serviceGetByUUIDRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// serviceGetByTypeRequest

// required .xtreemfs.pbrpc.ServiceType type = 1;
inline bool serviceGetByTypeRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serviceGetByTypeRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serviceGetByTypeRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serviceGetByTypeRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::xtreemfs::pbrpc::ServiceType serviceGetByTypeRequest::type() const {
  return static_cast< ::xtreemfs::pbrpc::ServiceType >(type_);
}
inline void serviceGetByTypeRequest::set_type(::xtreemfs::pbrpc::ServiceType value) {
  assert(::xtreemfs::pbrpc::ServiceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// serviceRegisterRequest

// required .xtreemfs.pbrpc.Service service = 1;
inline bool serviceRegisterRequest::has_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serviceRegisterRequest::set_has_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serviceRegisterRequest::clear_has_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serviceRegisterRequest::clear_service() {
  if (service_ != NULL) service_->::xtreemfs::pbrpc::Service::Clear();
  clear_has_service();
}
inline const ::xtreemfs::pbrpc::Service& serviceRegisterRequest::service() const {
  return service_ != NULL ? *service_ : *default_instance_->service_;
}
inline ::xtreemfs::pbrpc::Service* serviceRegisterRequest::mutable_service() {
  set_has_service();
  if (service_ == NULL) service_ = new ::xtreemfs::pbrpc::Service;
  return service_;
}
inline ::xtreemfs::pbrpc::Service* serviceRegisterRequest::release_service() {
  clear_has_service();
  ::xtreemfs::pbrpc::Service* temp = service_;
  service_ = NULL;
  return temp;
}
inline void serviceRegisterRequest::set_allocated_service(::xtreemfs::pbrpc::Service* service) {
  delete service_;
  service_ = service;
  if (service) {
    set_has_service();
  } else {
    clear_has_service();
  }
}

// -------------------------------------------------------------------

// serviceRegisterResponse

// required fixed64 new_version = 1;
inline bool serviceRegisterResponse::has_new_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void serviceRegisterResponse::set_has_new_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void serviceRegisterResponse::clear_has_new_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void serviceRegisterResponse::clear_new_version() {
  new_version_ = GOOGLE_ULONGLONG(0);
  clear_has_new_version();
}
inline ::google::protobuf::uint64 serviceRegisterResponse::new_version() const {
  return new_version_;
}
inline void serviceRegisterResponse::set_new_version(::google::protobuf::uint64 value) {
  set_has_new_version();
  new_version_ = value;
}

// -------------------------------------------------------------------

// configurationGetRequest

// required string uuid = 1;
inline bool configurationGetRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void configurationGetRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void configurationGetRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void configurationGetRequest::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& configurationGetRequest::uuid() const {
  return *uuid_;
}
inline void configurationGetRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void configurationGetRequest::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void configurationGetRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* configurationGetRequest::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* configurationGetRequest::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void configurationGetRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// configurationSetResponse

// optional fixed64 new_version = 1;
inline bool configurationSetResponse::has_new_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void configurationSetResponse::set_has_new_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void configurationSetResponse::clear_has_new_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void configurationSetResponse::clear_new_version() {
  new_version_ = GOOGLE_ULONGLONG(0);
  clear_has_new_version();
}
inline ::google::protobuf::uint64 configurationSetResponse::new_version() const {
  return new_version_;
}
inline void configurationSetResponse::set_new_version(::google::protobuf::uint64 value) {
  set_has_new_version();
  new_version_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::ServiceType>() {
  return ::xtreemfs::pbrpc::ServiceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::ServiceStatus>() {
  return ::xtreemfs::pbrpc::ServiceStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fDIR_2eproto__INCLUDED

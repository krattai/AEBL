This document contains random notes on performing certain function and other thoughts about past, current, or future of AEBL core.

~~~~

Boot splash screen (graphic) should include note indicating that AEBL contains Open Source software under, at least, GPLv2.0 and MIT licenses.

And guides or other available docs (placed in the ctrl folder or elsewhere on the applinace) should contain reference to open source licenses.

~~~~

Wishlist and other, non-code notes:

Set beta system to test code in field, without affecting production systems.
+ and patch them every hour.

Find way to automate things by text / email.

Cron format:

*     *     *   *    *        command to be executed
-     -     -   -    -
|     |     |   |    |
|     |     |   |    +----- day of week (0 - 6) (Sunday=0)
|     |     |   +------- month (1 - 12)
|     |     +--------- day of        month (1 - 31)
|     +----------- hour (0 - 23)
+------------- min (0 - 59)

~~~~

Code examples:

sed examples:
ip addr show eth0 | sed 's/://g' | sed 's/\/64//' | awk '/inet6 / {print $2}'

sed 's/%//' file > newfile
echo "68%" | sed "s/%$//" #assume % is always at the end.
echo "82%%%" | sed 's/%*$//'
echo "/this/is/my/path////" | sed 's!/*$!!'
echo $string | sed 's/[\._-]//g'
echo ${string//[-._]/}

this removes all instances
echo "8%2%%%" | sed 's/%//g'

~~~~

Notes on web interfaces:

First part from:
http://raspberrywebserver.com/cgiscripting/setting-up-nginx-and-uwsgi-for-cgi-scripting.html

sudo apt-get install nginx

sudo nano /etc/nginx/sites-enabled/default

I don't believe I actually made changes to default, but eventually it started, although not sure if before or after:

sudo service nginx restart

Apparently, this doesn't work properly due to not cgi configed:
sudo apt-get install uWSGI

so:
curl http://uwsgi.it/install | bash -s cgi /home/pi/uwsgi

This will probably take about 20 or more minutes as it builds,
may want to do this process post install, during video looping

Which means this may not be required:
sudo mkdir /usr/lib/cgi-bin

OK, should clean up from curl and install, so this might be necessary:
rm  uwsgi_latest_from_installer.tar.gz
rm -rf uwsgi_latest_from_installer

/home/pi/uwsgi_config.ini:
[uwsgi]
plugins = cgi
socket = 127.0.0.1:9000
chdir = /usr/lib/cgi-bin/
module = pyindex
cgi=/cgi-bin=/usr/lib/cgi-bin/
cgi-helper =.py=python

And this may be invalid, as uwsgi may now be ./uwsgi:
First did not work, second did:
sudo -u www-data ./uwsgi ./uwsgi_config.ini
sudo -u www-data uwsgi ./uwsgi_config.ini

And taking cue from raspCTL, make the app basically into daemon:
nohup sudo -u www-data ./uwsgi ./uwsgi_config.ini &

sudo nano /usr/lib/cgi-bin/hello.py

sudo chmod +x /usr/lib/cgi-bin/hello.py

ejabberd working
http://www.process-one.net/docs/ejabberd/guide_en.html

jabberpi working
http://www.softcognito.org/Raspberry_Pi_Communication_Bot.html
https://code.google.com/p/jhub1-xmpp/wiki/JabberPiUsage
http://www.raspberrypi.org/oracle-java-on-raspberry-pi/
http://elinux.org/RPi_Java_JDK_Installation

make sure users created:
bawt@irotsys.local - password
pi@irotsys.local - password

~~~~

String manipulation with bash:

http://tldp.org/LDP/abs/html/string-manipulation.html

http://www.thegeekstuff.com/2010/07/bash-string-manipulation/

Manipulating strings, character by character, with sed, from:
http://stackoverflow.com/questions/10551981/how-to-perform-a-for-loop-on-each-character-in-a-string-in-bash

```
$ echo "Hello world" | sed -e 's/\(.\)/\1\n/g'
H
e
l
l
o

w
o
r
l
d
```

String manipulation in loop, one char at a time:

```
foo=string
for (( i=0; i<${#foo}; i++ )); do
  echo ${foo:$i:1}
done
```

and

```
while test -n "$words"; do
   c=${words:0:1}     # Get the first character
   echo character is $c
   words=${words:1}   # trim the first character
done
```

~~~~

Various code snippets of unknown use:

while [ $COUNT -gt 0 ]; do
	echo "DATE: $CURRENT">> spy.txt
	
	ps axo user,pid,comm >> spy.txt  #run command ps to list all process and append it to thelog file
	
echo " "
	
echo " " > temp.txt

grep DATE spy.txt >> temp.txt
for array in ${array[at symbol]} #it will not let me post with the actual at symbol
do
    grep "$array" spy.txt >> temp.txt
done
	let COUNT=COUNT-1 #count down mechanism for loop
	sleep $TIME  #argument to wait so many seconds between iterationso fo main loop
done


~~~~~~~~~~~~~~~~~~~~~


iterations=3
delay=10

while getopts n:t: o
do   case "$o" in
     n)   iterations="$OPTARG";;
     t)   delay="$OPTARG";;
     [?]) echo "Usage: $0 [-n iterations] [-t delay] cmd" >&2
          exit 1;;
     esac
done
let 'shifter=OPTIND-1'
shift $shifter

rm -f out.last out.curr

loop=1
while test $loop -le $iterations
do
   "$@" 2>/dev/null > out.curr
   if test $loop -gt 1
   then
      if ! diff out.last out.curr >/dev/null
      then
        date
        diff out.last out.curr
        echo
      fi
   fi
   sleep $delay
   mv out.curr out.last
   let 'loop=loop+1'
done

rm -f out.last out.curr


~~~~~~~~~~~~~~~~


#!/bin/bash
trap "rm psmonitor.txt; echo Interupt encountered, exiting;  exit 1" SIGHUP SIGINT SIGTERM #trap to catch interupts , deletes output and prompts user with exit condition
CURRENT=$(date) 
	
usage(){
	echo "usage $0 -t[tseconds] -n[count]"
} #this function will print out the correct usage when the shell is run incorrectly 

COUNT=5
TIME=1

until [[ $1 == -* ]]
do
   array+=( "$1" )
   shift
done

while getopts :t:n: option #getopts to pass arguments to the script
do 
	case "${option}"
	 in 
		t) TIME="$OPTARG";;
		n) COUNT="$OPTARG";;
		
		\?) case "$OPTARG" in
			t) echo " missing time parameter." ;;
			n) echo " missing count parameter." ;;
			\?) echo "Error: unknown option -$option";;  #catch all error message
			esac
			usage #print usage to screen
			exit 0
			;;
	esac 
done

echo "DATE: $CURRENT" > spy.txt
ps axo user,pid,comm >> spy.txt
echo " " 

echo " " > temp.txt
grep DATE spy.txt >> temp.txt

for array in ${array[@]} 
do
    grep "$array" spy.txt | sed "s/^/Started:/">> temp.txt
done

let COUNT=COUNT-1


while [ $COUNT -gt 0 ]; do
	echo "DATE: $CURRENT"> spy.txt
	
	ps axo user,pid,comm >> spy.txt  #run command ps -e to list all process and append it to thelog file
	
echo " "
	

echo " " > temp1.txt
grep DATE spy.txt >> temp1.txt
for array in ${array[@]} 
do
    grep "$array" spy.txt >> temp1.txt
done
	let COUNT=COUNT-1 #count down mechanism for loop
	sleep $TIME  #argument to wait so many seconds between iterationso fo main loop
done
